%!TEX root = ../my_thesis.tex
\chapter*{Conclusions et perspectives}
\markboth{Conclusions et perspectives}{Conclusions et perspectives}
\addcontentsline{toc}{chapter}{Conclusions et perspectives}

\section*{Avantages et inconvénients de chaque approche}
\section*{Conclusions}
Dans le deuxième chapitre, des implémentations logicielles des algorithmes de codes polaires à liste sont proposées. L'originalité de ces implémentations tient à leur forte flexibilité. Cette flexibilité est inédite en comparaison des travaux publiés dans la littérature sur le même sujet. Tout d'abord, les données internes de l'algorithme sont représentées en virgule fixe, ce qui diminue l'empreinte mémoire et permet de réduire le temps nécessaire au décodage d'une trame. De plus, l'élagage de l'arbre de décodage est une simplification indispensable pour atteindre de hauts débits et de faibles latences de décodage. Cet élagage, dans les décodeurs proposés, est dynamiquement configurable. La flexibilité de l'élagage permet des compromis intéressants entre débit, latence et performance de décodage. Grâce à différentes optimisations, la flexibilité et la généricité du décodeur sont atteintes sans sacrifier le débit ou la latence de décodage. Une des versions de l'algorithme à liste, l'algorithme FASCL, permet même de dépasser le débit des implémentations de l'état de l'art sur les architectures x86. Des résultats d'implémentation des algorithmes de décodage de codes polaires à liste sont également proposés sur des architectures ARM. Les débits sont moindres, mais la consommation énergétique est réduite.

Dans le troisième chapitre, une architecture de processeur spécialisée pour le décodage de codes polaires est proposée. Le processeur fait partie de la famille des ASIP. Les outils de la marque Tensilica sont utilisés. Les processeurs conçus à l'aide des ces outils sont des processeurs de type RISC, dont le jeu d'instructions est étendu et la microarchitecture modifiée afin de les rendre plus efficaces pour une application donnée. Ils conservent toutefois la versatilité de architectures RISC classiques, et bénéficient d'un écosystème logiciel facilitant leur conception et le développement de programme les ciblant. Tout comme les implémentations du chapitre précédent, le programme est décrit logiciellement, dans un langage de haut niveau (C, C++, OpenCL). Les expérimentations et les mesures réalisées montrent que l'architecture de processeurs proposée permet d'atteindre des débits comparables à ceux obtenus sur les architectures ARM, tout en réduisant la consommation énergétique d'un ordre de grandeur.

Dans le quatrième chapitre, une architecture de processeur de type TTA est conçue. Configurable plus finement et d'une structure plus modulaire, ce type d'architecture se rapproche des implémentations matérielles dédiées, du point de vue de leur structure comme de celui de leurs performances. Tout comme les architectures du chapitre troisième, elles n'en restent pas moins versatiles et programmables. Elles sont également dotées d'un environnement de conception complet. Cet environnement est une suite logicielle libre développée par l'équipe \og Customized Parallel Computing \fg de l'université technique de Tampere (TUT). Contrairement aux architectures réalisées avec les outils de Tensilica, le modèle complet du processeur est produit par l'environnement, pour être utilisé par des logiciels de synthèse tiers. Deux architectures sont proposées. La première supporte l'algorithme SC seul. La seconde supporte les algorithmes SC et SCAN. Les deux sont synthétisées et implantées sur des circuits FPGA. Les résultats de synthèse de la première architecture montrent qu'elle permet de surpasser les débits obtenus sur les architectures x86, tout en réduisant la consommation énergétique de deux ordres de grandeur.

\section*{Perspectives}

Amélioration du tri dans l'algorithme liste sur cible x86 / arm.
SCL sur TTA
MANYCORE
